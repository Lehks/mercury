[header]
{
    "array": {
        "arrayJoin": "\n\n"
    }
}
[header]
/* eslint-disable */
/* tslint:disable */
const _ = require('lodash');
const TableUtils = require('mercury/dist/lib/core/generation/client/table-utils');
const ConnectionManager = require('../@connectionModule@');

class @tableName@ {
    static #DATA = {
        connectionManager: ConnectionManager,
        primaryKeyNames: @primaryKeyNames@,
        table: '@rdbmsTableName@'
    };

    static #RDBMS_TO_PROPERTY_NAME_MAP = @rdbmsToPropertyNameMap@;

    static #PROPERTY_TO_RDBMS_NAME_MAP = @propertyToRdbmsNameMap@;

@columnConstants:#array@

    primaryKey;
    #primaryKeyArray;

    constructor(primaryKey) {
        this.#primaryKeyArray = [primaryKey];
        this.primaryKey = primaryKey;
    }

    static getConnectionManager() {
        return @tableName@.#DATA.connectionManager;
    }

    static async insert(data, connection) {
        const result = await TableUtils.insert(
            @tableName@.#DATA,
            data,
            @tableName@.#PROPERTY_TO_RDBMS_NAME_MAP,
            connection
        );

        return new @tableName@(result.insertId);
    }

    static async findById(primaryKey, checkExistence = true, connection) {
        const ret = new @tableName@(primaryKey);

        if (checkExistence && !(await ret.exists(connection))) {
            throw new Error();
        }

        return ret;
    }

@getters:#array@

    async multiGet(columns, connection) {
        return TableUtils.multiGetInternal(
            @tableName@.#DATA,
            columns.map(col => col.rdbmsName),
            this.#primaryKeyArray,
            @tableName@.#RDBMS_TO_PROPERTY_NAME_MAP,
            connection
        );
    }

    async multiSet(values, connection) {
        return TableUtils.multiSetInternal(
            @tableName@.#DATA,
            values,
            this.#primaryKeyArray,
            @tableName@.#PROPERTY_TO_RDBMS_NAME_MAP,
            connection
        );
    }

@setters:#array@

    equals(other) {
        return _.isEqual(this.#primaryKeyArray, other.#primaryKeyArray);
    }

    async exists(connection) {
        return TableUtils.exists(@tableName@.#DATA, this.#primaryKeyArray, connection);
    }

    async delete(connection) {
        return TableUtils.deleteInternal(@tableName@.#DATA, this.#primaryKeyArray, connection);
    }
}

module.exports = @tableName@;
