# Mercury

A library that generates both SQL to create a database and a JavaScript or TypeScript client for that database.

The intention of this library is, that it allows the definition of a database layout in JSON. This definition can then be used

1. to create the tables, columns, constraints, etc. in a database
2. to generate a JavaScript / TypeScript client that can be used to create, query, modify and delete data in the database.

The library was also not designed to be bound to a specific RDBMS. Instead, it uses a driver system for the generation of SQL and to connect to the database(s) during runtime.

The goal of the library is, that no SQL (especially RDBMS specific SQL) needs to be written by hand.

## Contents

-   [Installation](#installation)
-   [Basic Setup](#basic-setup)
    -   [Drivers](#drivers)
    -   [Database Definition File](#database-definition-file)

## Installation

```
npm install mercury
```

There is no need to install additional typings (such as the package `@types/mercury`), the module comes with its typings included.

This package is only the main mercury package. Additionally, at least one driver is also required.

## Basic setup

Before any client can be generated and used, the database configuration needs to be set up.

### Drivers

As already stated in the chapter [Installation](#installation), Mercury requires at least one driver to be installed in addition to its core `mercury` package.

Drivers are regular NPM packages and can be installed with the command

```
npm install <driver name>
```

Drivers are responsible for both the generation of SQL and the connection to a database at runtime. The SQL that was generated is only compatible to the driver that it was generated by.

The currently existing / planned drivers are:

<!-- todo npm links in table below -->

| Driver                    | RDBMS                                   | Note                                                                     |
| ------------------------- | --------------------------------------- | ------------------------------------------------------------------------ |
| `mercury-driver-mariadb`  | [MariaDB](https://mariadb.com/)         | Uses Module [mariadb](https://www.npmjs.com/package/mariadb) internally. |
| `mercury-driver-postgres` | [Postgres](https://www.postgresql.org/) | Planned but not available yet.                                           |

Examples in this README always use the driver `mercury-driver-mariadb`.

### Database Definition File

After the required driver(s) have been installed, the central file of Mercury needs to be created: the Database Definition File (or short DDF). This file defines the database(s), their tables, columns, and much more. The DDF contains everything that is required to create the database and generate and use the client.

The DDF is a JSON file, usually called `database-definition.json`. The JSON schema file can be found at `<mercury-root-directory>/res/schema/database-definition.schema.json`.

A rather small and simple example for a DDF would be:

```json
{
    "databases": {
        "my-database": {
            "connection": {
                "host": "my-database-host.com",
                "user": "user",
                "password": "password",
                "driver": "mercury-generator-mariadb"
            },
            "tables": {
                "users": {
                    "columns": {
                        "id": {
                            "type": {
                                "base": "int"
                            },
                            "nullable": false
                        },
                        "name": {
                            "type": {
                                "base": "string"
                            },
                            "nullable": false,
                            "unique": true
                        }
                    },
                    "primaryKey": "id"
                }
            }
        }
    }
}
```

This DDF creates a single database `my-database`. This database contains a single table called `users` which in turn contains two columns `id` and `name`.

`id` has the type `int` and can never be `null`. `name` is a `string` and can never be `null` but must be unique. The primary key of the table is `id`.

In addition to the aforementioned database schema, there is more information contained in the DDF. `databases.my-database.connection` contains the data that is used to connect to the database as well as the driver that will be used for that connection. For further information about this connection data, see the Chapter [Connections](#connections).

### Generating client and SQL and setting up the database

In order to generate the client and the SQL from a DDF, call

```
mercury generate
```

in the directory of the DDF. By default, this will place the generated files next to the DDF. See chapter [Changing the Client and SQL output directory](#changing-the-client-and-sql-output-directory) for information on how to change the output directory.

Afterwards, use

```
mercury setup-database
```

to create the relations in the database.

Now, both the client and database are ready to use. See chapter [Usage](#usage) on how to do that.

## Advanced setup

The chapter [Basic Setup](#basic-setup) only covered the very basics of DDF creation. This chapter will cover all of the options that the DDF
provides.

### Columns

Columns have already described above, however, this chapter will give a more detailed description. The JSON data of a column looks like this:

```json
{
    "type": {
        /* the type of the column. described in the following chapter */
    },
    "nullable": "true | false",
    "unique": "true | false"
}
```

-   `type`: The type of the column. Types are described in the following chapter.
-   `nullable`: A boolean value that determines whether the column is nullable. Defaults to `false`.
-   `unique`: A boolean value that determines whether the values in the column need to be unique. Defaults to `false`.

### Types

There are a multitude of predefined types. These can be grouped into the following groups:

1. Integer Numbers
2. Floating Point Numbers
3. Strings
4. Temporal Types
5. Boolean

The client-side data types that represent each of the types is defined by the client generator.

#### Integer Numbers

There are three integer types:

| Base Type   | Size             |
| ----------- | ---------------- |
| `small-int` | At least 2 bytes |
| `int`       | At least 4 bytes |
| `big-int`   | At least 8 bytes |

The JSON of an integer type looks like this:

```JSON
{
    "base": "'small-int' | 'int' | 'big-int'",
    "unsigned": "<boolean>",
    "default": "<integer value> | 'auto-increment' | null"
}
```

The meaning of the properties are:

1. `unsigned`: A boolean value that decides whether the value is signed or unsigned. This will default to `false`.
2. `default`: The default value of the column. The possible values are:
    1. An integer value. The default will be this exact value.
    2. The string `auto-increment`. Each inserted row will have a different value. This can be used to generate values for primary key columns.
    3. The keyword `null`. This is only available if the column is nullable and it will cause the value to be `null` by default.
    4. Omitting this property altogether. This will cause for no default value to be set.

#### Floating Point Types

There are two floating point types:

| Base Type | Kind                    |
| --------- | ----------------------- |
| `float`   | Single precision number |
| `double`  | Double precision number |

The JSON of an floating point type looks like this:

```JSON
{
    "base": "'float' | 'double'",
    "unsigned": "<boolean>",
    "default": "<floating point value> | null"
}
```

The meaning of the properties are:

1. `unsigned`: A boolean value that decides whether the value is signed or unsigned. This will default to `false`.
2. `default`: The default value of the column. The possible values are:
    1. A floating point value. The default will be this exact value.
    2. The keyword `null`. This is only available if the column is nullable and it will cause the value to be `null` by default.
    3. Omitting this property altogether. This will cause for no default value to be set.

#### Strings

There are three string types:

| Base Type  | Kind                      |
| ---------- | ------------------------- |
| `var-char` | Variable length string    |
| `char`     | Fixed length string       |
| `enum`     | Predefined set of strings |

The JSON data for `var-char` and `char` types are very different from the one for `enum`.

The data for `var-char` and `char` looks like this:

```json
{
    "base": "'var-char' | 'char'",
    "length": "<positive integer>",
    "default": "<string> | null"
}
```

1. `length`: The maximum length of the string.
2. `default`: The default value of the column. The possible values are:
    1. A string value. The default will be this exact value.
    2. The keyword `null`. This is only available if the column is nullable and it will cause the value to be `null` by default.
    3. Omitting this property altogether. This will cause for no default value to be set.

The data of `enum`s looks like this:

```json
{
    "base": "'enum'",
    "literals": ["'LITERAL_1'", "'LITERAL_2'", "'LITERAL_N'"],
    "default": "<enum literal> | null"
}
```

1. `literals`: An array of the allowed string literals.
2. `default`: The default value of the column. The possible values are:
    1. A value from `literals`. The default will be this literal.
    2. The keyword `null`. This is only available if the column is nullable and it will cause the value to be `null` by default.
    3. Omitting this property altogether. This will cause for no default value to be set.

#### Temporal Types

There are three kinds of temporal types: `date`, `time` and `date-time`. `date` stores only dates, `time` only stores time and `date-time` stores both.

The data of temporal types looks like this:

```json
{
    "base": "'date' | 'time' | 'date-time'",
    "default": "<date / time / date-time string> | 'NOW' | null"
}
```

1. `default`: The default value of the column. The possible values are:
    1. Either a date, time or date-time string (depending on the base type). The default will be this value.
    2. The string `NOW`. This will insert the current date and time as a default value.
    3. The keyword `null`. This is only available if the column is nullable and it will cause the value to be `null` by default.
    4. Omitting this property altogether. This will cause for no default value to be set.

#### Boolean

There is only a single boolean type called `boolean`. It represents a value that is either `true` or `false`.

The data of the boolean type looks like this:

```json
{
    "base": "'boolean'",
    "default": "true | false | null"
}
```

1. `literals`: An array of the allowed string literals.
2. `default`: The default value of the column. The possible values are:
    1. The keyword `true` or `false`. The default value will be the respective value.
    2. The keyword `null`. This is only available if the column is nullable and it will cause the value to be `null` by default.
    3. Omitting this property altogether. This will cause for no default value to be set.

### Compound Primary Keys

As shown in the [Database Definition File](#database-definition-file) example, a primary key can be set using the property `databases.<database>.primaryKey`. In the example, only a single column was used as a primary key. However, it is also possible to use multiple columns as primary. In that case, instead of a simple string that contains the column name, an array of strings where each element is a column name is used.

The following is same example as in [Database Definition File](#database-definition-file) with both columns `id` and `name` as primary key.

```json
{
    "databases": {
        "my-database": {
            "connection": {
                "host": "my-database-host.com",
                "user": "user",
                "password": "password",
                "driver": "mercury-generator-mariadb"
            },
            "tables": {
                "users": {
                    "columns": {
                        "id": {
                            "type": {
                                "base": "int"
                            },
                            "nullable": false
                        },
                        "name": {
                            "type": {
                                "base": "string"
                            },
                            "nullable": false,
                            "unique": true
                        }
                    },
                    // this is now a compound primary key
                    "primaryKey": ["id", "name"]
                }
            }
        }
    },
    "meta": {
        "clientGenerator": {
            "name": "mercury-generator-js",
            "data": {
                "generateTypings": true
            }
        }
    }
}
```

### Foreign Keys

Foreign keys are defined on a table level just like they would have been in regular SQL. A DDF with a foreign key looks like this:

```json
{
    "databases": {
        "my-database": {
            "connection": {
                "host": "my-database-host.com",
                "user": "user",
                "password": "password",
                "driver": "mercury-generator-mariadb"
            },
            "tables": {
                "users": {
                    "columns": {
                        "id": {
                            "type": {
                                "base": "int"
                            },
                            "nullable": false
                        },
                        "name": {
                            "type": {
                                "base": "string"
                            },
                            "nullable": false,
                            "unique": true
                        }
                    },
                    "primaryKey": "id"
                },
                "user-data": {
                    "columns": {
                        "id": {
                            "type": {
                                "base": "int"
                            },
                            "nullable": false
                        },
                        "user-id": {
                            "type": {
                                "base": "int"
                            },
                            "nullable": false
                        }
                    },
                    "constraints": {
                        "foreignKeys": {
                            "FK_users": {
                                "on": "user-id",
                                "references": {
                                    "table": "users",
                                    "column": "id"
                                },
                                "onUpdate": "restrict",
                                "onDelete": "cascade"
                            }
                        }
                    }
                }
            }
        }
    },
    "meta": {
        "clientGenerator": {
            "name": "mercury-generator-js",
            "data": {
                "generateTypings": true
            }
        }
    }
}
```

The foreign key in this example, called `FK_users`, is placed on the column `user-id` in the table `user-data` and references the column `id` in the table `users`. Updates to the ID are restricted and deletions will cascade.

A generic foreign key looks like this:

```json
{
    "foreignKeys": {
        "<foreign key name>": {
            "on": "<column in current table>",
            "references": {
                "table": "<foreign table>",
                "column": "<column in foreign table>"
            },
            "onUpdate": "'restrict' | 'cascade' | 'set-null' | 'no-action' | 'set-default'",
            "onDelete": "'restrict' | 'cascade' | 'set-null' | 'no-action' | 'set-default'"
        }
    }
}
```

### Check Constraints

TODO

### Triggers

TODO

### Meta Settings

There are some meta-settings that can be used to modify the behavior of Mercury. These settings are stored in meta-objects. These objects exist on a global, database, table and column level. The paths to these objects are:

-   global: `meta`
-   database: `databases.<database name>.meta`
-   table: `databases.<database name>.tables.<table name>.meta`
-   column: `databases.<database name>.tables.<table name>.columns.<column name>.meta`

#### Changing the client and SQL Output Directory

The SQL an client output directories can be changed with the properties `clientOutputDir` and `sqlOutputDir` respectively. The paths in these properties can be absolute or relative. Should they be relative, then they are relative to the directory that the DDF is placed in.

The output directory can only be set in the global meta object.

#### Name Overrides and Conventions

The names of tables, columns and the symbol names in the client can be changed. There are two ways of doing that:

1. directly setting a name (e.g. setting the name of the getter of a specific column to a specific value)
2. changing the conventions that apply to all names (e.g. all methods in the client are supposed to use lower camel case)

##### Directly Setting the Name

Names can only directly be changed on the level that the object that the name belongs to was defined. For example, the name of the database can only be defined in the meta object on database level whereas the name of a column can only be changed on column level.

When a name is changed directly, the naming conventions will not apply to this particular name.

###### Database Names

There are two names that can be changed for a database. Firstly, the name of the database in the RDBMS can be changed using the property `rdbmsName`. Secondly, the name of the module that is generated for the database can be changed using the property `moduleName`. Both names default to the name that is the key in the `databases` object.

###### Table Names

There are three names that can be changed for a table. Firstly, the name of the table in the RDBMS can be changed using the property `rdbmsName`. Secondly, the name of the class that is generated for the table can be changed using the property `className`. Thirdly, `moduleName` determines the filename that the class is in. All three names default to the name that is the key in the `tables` object.

###### Column Names

In the case of columns, there are a lot of names to be changed:

1. `rdbmsName`: Changes the name of the column in the database. Defaults to the key in the `columns` object.
2. `getterName`: The name of the getter for that column. Defaults to `get<RDBMS name>`.
3. `setterName`: The name of the setter for that column. Defaults to `set<RDBMS name>`.
4. `constantName`: The name of the constant of that column. See [Table Modules](#table-modules).

##### Naming Conventions

In contrast to the setting of fixed names, naming conventions can be set on any level (although changing the conventions on column level rarely makes sense). The conventions then apply to all of the names that are on the same level or below (e.g. the globally set conventions apply to all databases their tables and columns whereas a convention set on database level will apply only to that database and its tables and columns).

Also, the conventions have cascading behavior. For example, when a convention is set on global level and another convention is set on database level for a single database, then the global convention will apply to all databases except the one that has its conventions set on database level.

The available conventions are:

1. camelCase (`camel-case` in DDF)
2. UpperCamelCase (`upper-camel-case` in DDF)
3. snake_case (`snake-case` in DDF)
4. minus-case (`minus-case` in DDF)
5. CONSTANT_CASE (`constant-case` in DDF)

These properties control the naming conventions:

1. `naming.rdbmsDatabaseNameConvention`: The name of the database in the RDBMS. Defaults to `upper-camel-case`. Does not exist on table and column level.
2. `naming.rdbmsTableNameConvention`: The name of the tables in a database. Defaults to `upper-camel-case`. Does not exist on column level.
3. `naming.rdbmsColumnNameConvention`: The name of the columns in a database. Defaults to `camel-case`.
4. `naming.moduleNameConvention`: The name of all modules in a client (and also the name of directories). Defaults to `minus-case`. Does not exist on column level.
5. `naming.classNameConvention`: The name of all classes in a client. Defaults to `upper-camel-case`. Does not exist on column level.
6. `naming.methodNameConvention`: The name of all methods in a client class (including getters and setters). Defaults to `camel-case`.
7. `naming.constantNameConvention`: The name of the column constants. Defaults to `constant-case`.

##### Singular Class Names

There is also another naming option, called `singularClassNames`. It is a boolean value. When `true` (which is the default), every table name that is in plural will be turned into singular when creating the client-class name of that table. For example, a database `Users` will have a class `User`. The singular class names option can be set on global and database level.

### Connections

Connections are defined on database level. They define the driver that is used for the connection and the data that is used to connect to the database. This data is split up into two kinds, for one the public data which may be accessed by anyone and the credentials, which is all data that is sensitive and should not be shared with the world (such as username and passwords). The credentials also include data that may change (such as the database IP or hostname, which may change when the database is moved to a different machine).

The public connection data is always stored in the DDF itself. It is also possible to store the credentials in the DDF, but there are also other ways to store the credentials. In total, there are three ways to store the credentials.

1. internal: The credentials are placed directly in the DDF as a JSON object. This variant was used in all of the previous examples.
2. external: The JSON object that would have been placed directly in the DDF in the _internal_ variant is now placed in a separate file. This way, the DDF can be shared and the credentials file can be left out. The DDF will only contain the path to the credentials file.
3. environment: The credentials will be loaded from environment variables. The DDF will only contain a special identifier that denotes the usage of environment variables.

The JSON for connection data looks like this:

```json
{
    "driver": "<driver name>",
    "default": {
        "credentials": "<credentials, see chapters below>",
        "data": {
            "key1": "value1",
            "key2": "value2",
            "keyN": "valueN"
        }
    },
    "admin": {
        "credentials": "<credentials, see chapters below>",
        "data": {
            "key1": "value1",
            "key2": "value2",
            "keyN": "valueN"
        }
    }
}
```

The properties have the following meanings:

-   `driver`: The name of the driver. This is the same name as the NPM module that the driver resides in.
-   `default` and `admin`: The two connection types, each with their own credentials and additional data. This system is described further below.
-   `default|admin.credentials`: The credentials of that connection. This is described further below.
-   `default|admin.data`: An object that contains arbitrary data. This data is passed to the driver and can be used to configure it. The accepted keys and their meanings are thusly driver dependent.

#### 'default' AND 'admin' connections

It is possible to have two kind of connections, `default` and `admin`. The first is used during runtime for DML statements whereas the latter is used for DDL statements when setting up the database (e.g. with the command `mercury setup-database`). These two connections allow for different users (i.e. different sets of permissions).

The `admin` connection is optional and the `default` connection will be used if no explicit `admin` connection exists.

##### Credentials

Similar to the public connection data object, does the credentials not include any required properties and consists of arbitrary keys and values. However, there are three predefined credential values that may or may not be used: `host`, `user` and `password`. These three values do not have a special meaning, but they are recommended to be used by drivers in oder to create a more consistent usage across drivers.

As already explained before, there are three different ways to pass credentials to the DDF: `internal`, `external` and `environment`.

When using the `internal` method, the credentials JSON will simply be placed in the DDF file in the property `databases.<database name>.connection.default|admin.credentials`. When using the `external` method, the credentials JSON will be placed in a separate file and `databases.<database name>.connection.default|admin.credentials` will contain the path to that file as a string. The path may be absolute or relative. When it is relative, then the path will be relative to the directory that the DDF is in. Lastly, when using the `environment` method, the following system is used:

A single environment variable exists for each property that would have been part of the credentials object. The schema is `<prefix>_<database>_<key>`. The prefix is either `MERCURY_DEFAULT` or `MERCURY_ADMIN`, depending on the connection that the value is for (`default` or `admin`). The database is the name of the database that the credentials are for. Note that the name of the database may contain the character `-` which may not be allowed in an environment variable. Therefore, it is possible to substitute `-` with `_`. Lastly, key is the same key that it would have been in the credentials object. For example, the following credentials for the database `my-database`:

```json
{
    "host": "my-host.com",
    "user": "user",
    "password": "password"
}
```

would have the following environment variables (for the `default`) connection:

-   `MERCURY_DEFAULT_my_database_host`
-   `MERCURY_DEFAULT_my_database_user`
-   `MERCURY_DEFAULT_my_database_password`

Environment variables can be used as credential provider by settings the value of `databases.<database name>.connection.default|admin.credentials` to `ENVIRONMENT`.

### Column Definitions

Column Definitions can be used to avoid having to re-define the same columns again and again. Instead, a column will be defined a single time and then be referenced multiple times throughout the DDF. This saves time and space, but also avoids mistakes. For example, the types of primary keys are often the same for all tables. Column definitions allow it to define a primary key column once and then use it for every table. Names are not part of a column definition, so they can be used for columns of different names.

Column definitions are defined globally like this:

```json
{
    "columnDefinitions": {
        "#<definition name>": {
            /* regular column data as described in chapter 'Columns' */
        }
    }
}
```

As shown, a column definition is simply a regular column (as described in [Columns](#columns)) that is defined outside of any database. It is also important to note that the name of a column definition needs to start with a `#`. This is to make sure that references to column definitions are identifiable as such.

In order to use a column definition, they need to be referenced in a table. That is done by replacing the definition of a column with a string that contains the name of the definition.

For example, the following DDF uses a column definition:

```json
{
    "databases": {
        "my-database": {
            "connection": {
                "host": "my-database-host.com",
                "user": "user",
                "password": "password",
                "driver": "mercury-generator-mariadb"
            },
            "tables": {
                "users": {
                    "columns": {
                        "id": "#pk"
                    },
                    "primaryKey": "id"
                }
            }
        }
    },
    "meta": {
        "clientGenerator": {
            "name": "mercury-generator-js",
            "data": {
                "generateTypings": true
            }
        }
    },
    "columnDefinitions": {
        "#pk": {
            "type": {
                "base": "int"
            },
            "nullable": false
        }
    }
}
```

### Type Definitions

Type definitions are very similar to [Column Definitions](#column-definitions). As their name implies, they are predefined types instead of columns. This can be useful if the types of two columns are supposed to be the same, but their nullableness and uniqueness are supposed to be different.

Type definitions are created like this:

```json
{
    "columnDefinitions": {
        "&<definition name>": {
            /* regular type data as described in chapter 'Types' */
        }
    }
}
```

As shown, a type definition is simply a regular type (as described in [Types](#types)) that is defined outside of any database. It is also important to note that the name of a column definition needs to start with a `&`. This is to make sure that references to type definitions are identifiable as such.

For example, the following DDF uses a column definition:

```json
{
    "databases": {
        "my-database": {
            "connection": {
                "host": "my-database-host.com",
                "user": "user",
                "password": "password",
                "driver": "mercury-generator-mariadb"
            },
            "tables": {
                "users": {
                    "columns": {
                        "id": {
                            "type": "&pk",
                            "nullable": false
                        }
                    },
                    "primaryKey": "id"
                }
            }
        }
    },
    "meta": {
        "clientGenerator": {
            "name": "mercury-generator-js",
            "data": {
                "generateTypings": true
            }
        }
    },
    "typeDefinitions": {
        "&pk": {
            "base": "int"
        }
    }
}
```

It is also important to note that it is possible to use type definitions inside of column definitions.

### Partial Tables

Partial tables are tables that can be used to implement a kind of inheritance for tables. A partial table defines columns, primary key and constraints like any other table, but it will not create an actual table in the database. Instead, other, actual tables, can inherit from a partial table and will then gain all the columns, primary keys and constraints from the partial table (in addition to the columns, primary keys and constraints that are defined by the table itself).

The obvious advantage of partial tables is, that they save space and avoid redundancies (in a similar way that column and type definitions do). However, there is an additional benefit: each partial table will have a class in the client and the tables that inherit from another partial table will also inherit from the class of the respective partial table.

Partial tables are defined on global-level like this:

```json
{
    "databases": {
        "my-database": {
            "connection": {
                "host": "my-database-host.com",
                "user": "user",
                "password": "password",
                "driver": "mercury-generator-mariadb"
            },
            "tables": {
                "users": {
                    "columns": {
                        "extends": "@users-base",
                        "name": {
                            "type": {
                                "base": "var-char",
                                "length": 255
                            },
                            "nullable": false
                        }
                    }
                }
            }
        }
    },
    "meta": {
        "clientGenerator": {
            "name": "mercury-generator-js",
            "data": {
                "generateTypings": true
            }
        }
    },
    "partialTables": {
        "@users-base": {
            "columns": {
                "id": {
                    "type": {
                        "base": "int"
                    },
                    "nullable": false
                }
            },
            "primaryKey": "id"
        }
    }
}
```

In this case, the partial table is `@users-base` and it contains the definition for the column `id` and it also makes that column the primary key. Also, as shown in this example, the names of partial tables need to start with `@` to identify them as partial tables (similarly to column and type definitions that start with `#` and `&` respectively).

##### Primary Keys

Should both the partial table and the actual table define a primary key, then the primary keys will be combined into a single, compound primary key.

#### Inheritance Chains

It is possible to create inheritance chains by making a partial table inherit from another. These chains can be as long as needed, but they must not contain circular dependencies (as in a chain with the partial tables `A`, `B` and `C` where `A` inherits from `B` which inherits from `C` which inherits from `A`).

#### Multi Inheritance

It is not possible to have multi inheritance. This means, that a table can only inherit from a single partial table.

#### Partial Tables In Different Databases

Partial tables are defined on global level. However, each database will have its own class for the partial table. This means, that tables in different databases that extend the same partial table will still be incompatible and not share a parent class.

### Multiple Databases

So far, each example only consisted of a single database. It is however possible for multiple databases to exist. These can simply be added to the `databases` object like this:

```json
{
    "databases": {
        "my-first-database": {
            /* definition for database my-first-database */
        },
        "my-second-database": {
            /* definition for database my-second-database */
        }
    }
}
```

### Including Other Database Definitions

It is possible to include other DDFs into the main DDF. This is done via the property `includes` on global level. This property is a string array that contains the paths to the DDFs that should be included.

For example:

```json
{
    "includes": ["./my-other-database-definition.json"]
}
```

is a DDF that simply includes the DDF `my-other-database-definition.json` from the same directory.

These paths can be:

1. absolute: regular absolute paths
2. relative: regular relative paths relative to the directory that the DDF is in. Relative paths _must_ be preceded by `./`.
3. NPM module: relative paths that are not preceded by `./` will be relative to the `node_modules` directory. In the case that the path points to a directory, Mercury will try to use the file `<directory>/database-definition.json`. This is only possible with NPM module paths and not absolute or relative paths. This can be used to include a DDF that was provided by a NPM package in the same way that the packages main module would be imported into a JavaScript file.

In conclusion, the way that Mercury loads include files is very similar to the system that is used by NodeJS to resolve modules.

#### Use-Cases

Includes can be used to split up a single DDF into multiple, smaller and easier to read DDFs. It can also be used to include DDFs that have been provided by NPM packages. This way, a module can provide a library that can be used by others or it might also set up their required databases on their own without the using developers interaction.

##### Providing Credentials

Credentials can be passed to included DDFs via the external or environment methods. The paths to external credential files will still be relative to the main DDF, even if it is placed in a database in an included DDF. Environment credentials still work in the same way that they did before.

#### Recursive Inclusion

A DDF can include DDFs which may include other DDFs (which may again include other DDFs and so on). There is no restriction to this recursion, it is event possible to have circular dependencies (as in DDF A includes DDF B which includes DDF C which includes DDF A).

##### Inclusion Details

DDFs will be included by simply merging the included DDF object into the main DDF object. This means, that all names (such as type definition names, database names, etc.) still need to be unique across both DDFs. The global meta will _not_ be merged, any meta definitions in an included DDF will be ignored.

## Usage

This chapter describes how the generated clients can be used.

### Generated Modules

For each database, there are a bunch of generated modules:

#### Connection Module

There is a single connection module for each database. This module is, for example, used to create transactions and low level database access. See [Transactions](#transactions) and [Low Level Database Access](#low-level-database-access).

The connection module can be found at the path `<js output directory>/<database name>.js`.

#### Table Modules

For each table in a database exists a separate module. These modules contain the table classes of their respective table. The table classes also contain the so called column constants. These are special constants, each of which identify a single column in their respective table. These constants are, among others, used be the [Query Builder](#query-builder).

The table modules can be found at the path `<js output directory>/<database name>/tables/<table name>.js`.

#### Partial Table Modules

Just as it is the case with regular tables, each partial table has its separate module. These modules also provide a class for each partial table. The table classes of tables that extend partial tables also inherit their partial table classes.

The partial table modules can be found at the path `<js output directory>/<database name>/partial-tables/<partial table name>.js`.

#### Query Builder Module

Each database also has a query builder module. This module is further described in the chapter [Query Builder](#query-builder).

The table modules can be found at the path `<js output directory>/<database name>/query-builder.js`.

### Inserting Rows

Rows can be inserted into a table by using the static method `.insert()` in the class of the table that data is supposed to be inserted into. The method expects a single object that provides the values for the columns. For a table with the columns `id` (`int`) and `name` (`var-char`), the object would look like this:

```ts
{
    id: number,
    name: string
}
```

The return value of `.insert()` is the newly created row as an instance of the table class.

#### Default Values

Generally, all values in the aforementioned object are required. However, should a column have a default column, then the value in the object becomes optional and the column will have the default value if no value is provided in the object.

#### Example

For a table `users` (class name is `User`) with the columns `id` (`int` and no default), `name` (`var-char` and no default) and `creationDate` (`date-time` and default `NOW`), an insert statement could look like this:

```ts
const user = await User.insert({
    id: 42,
    name: 'my-new-user'
});
```

The resulting row would look like this:

| `id` | `name`        | `creationDate`                           |
| ---- | ------------- | ---------------------------------------- |
| `42` | `my-new-user` | `<the date and time of the method call>` |

### Query Data By ID

After data has been inserted into a table, `.findById()` provides a simple way to query that data. It is a static method that exists in each table class (just like `.insert()` is) and it is used to query a single row by the value of its primary key.

The parameters depend on the type of primary key that the table has:

1. single primary key: The method simply takes a single value (which is the value of the primary key).
2. multiple primary keys: The method takes an object. Each key in the object is a primary key column and each value is the value of the respective column.

The return value of the method is either an instance of the respective table class or `null` if no row with the given primary key exists.

#### Example

The following code would be used to query the user that was inserted in the [Inserting Rows Example](#inserting-rows):

```ts
const user = await User.findById(42);
```

### Querying Column Data

After a reference to a table class has been acquired, that class provides getter and setter methods for each of its columns. For example, the column `name` (`var-char`) would have the getter `.getName()` and the setter `.setName()`.

Aside from these getters and setters for single columns, there are also the methods `.multiGet()` and `.multiSet()`. These can be used to get and set multiple column values at a time.

#### `.multiGet()`

The parameters passed to `.multiGet()` is a list of the columns that need to be queried. The return value is an object where each key is a name of a queried column and the value is the respective value of the column. For example, querying all the data from the user that was created in [Inserting Rows Example](#inserting-rows) would look like this:

```ts
const data = await user.multiGet(User.ID, User.NAME, User.CREATION_DATE);
```

The result object (called `data` in this case) would be:

```ts
{
    id: 42,
    name: 'my-first-user',
    date: <the date and time of the method call>
}
```

#### `.multiSet()`

`.multiSet()` only expects a single parameter, which is an object that contains all of the columns and their values that need to be updated. The keys in that object are the names of the columns and the values are the new column values (just like it is the case with the return value of `.multiGet()`). All of the properties in the object are optional and only those columns that are actually present will be set. Columns that are absent from the passed object will remain untouched.

For example, setting the user name and the creation date of the user that was created in [Inserting Rows Example](#inserting-rows) would look like this:

```ts
await user.multiSet({
    name: 'my-updated-user',
    creationDate: new Date()
});
```

### Comparing Table Rows

The method `.equals()` can be used to compare two instances of the same table class. The method returns `true` if the two instances reference the same row (i.e. their primary keys are the same) and `false` if they are not. The method takes the row that it should be compared to as a parameter.

In the case of a single primary key, it would also be possible to compare the objects using the `.Id` property, however this is not possible with multiple primary keys, because `.Id` will be an objects and objects cannot be compared as easily. For the sake of consistency, `.equals()` should be used in both cases.

Note that comparing two rows does not involve the database. This is possible because the method will simply compare the primary key values which are always stored on the client side.

For example, comparing the user from the example in [Inserting Rows Example](#inserting-rows) to another user stored in the variable `otherUser` would be done like this:

```ts
if (user.equals(otherUser)) {
    // users are the same
} else {
    // users are not the same
}
```

### Checking For Row Existence

The method `.exists()` checks whether a table class instance actually references a row in the database. It takes no arguments and returns a boolean value.

The method works by checking whether the client side stored primary key values exist in the database. That means that Mercury can not differentiate between a row that was actually deleted or a row where the primary key(s) value(s) changed.

For example, checking whether the user from the example in [Inserting Rows Example](#inserting-rows) would be done like this:

```ts
if (await user.exists()) {
    // user exists
} else {
    // user does not exist
}
```

### Deleting Rows

Rows can be deleted with the method `.delete()`. It takes no arguments and does not return anything.

For example, deleting the user that was created in [Inserting Rows Example](#inserting-rows) would be done like this:

```ts
await user.delete();
```

### Query Builder

The query capabilities of table classes are not able to perform complex queries (e.g. queries that include multiple tables, joins or sub-queries). Instead, the module `QueryBuilder` needs to be used. A query builder exists for each database. It features a fluent API that is similar to regular SQL syntax.

There are four types of queries:

1. select
2. insert
3. update
4. delete

#### Select Queries

In order to create a select query, use the function `QueryBuilder.select()`. It takes the column constants of the columns that should be queried. In addition to that, it is also required to have a call to the method `.from()` (which can be called on the return object of `.select()`). The table that the data should be queried from needs to be passed to this method.

Querying the column `name` from a table user `User` would look like this:

```ts
QueryBuilder.select(User.NAME).from(User);
```

Note that this call chain only creates the query. Executing queries and their return values is further explained in the chapter [Executing Queries](#executing-queries).

##### Select \* And Select 1 Queries

Instead of passing column constants, it is also possible to pass the strings `'*'` and `'1'` to `.select()`. This does the same as `SELECT * FROM <table>` and `SELECT 1 FROM <table>` would do in regular SQL.

##### Joins

Joins are created by using certain static method that exist in each of the table classes. For example, a `NATURAL JOIN` on the two tables `Users` and `UserData` would look like this:

```ts
Users.naturalJoin(UserData);
```

The return value of such a call can be passed to the `.from()` method. The following joins exist:

| Join             | Method(s)                                                                                      |
| ---------------- | ---------------------------------------------------------------------------------------------- |
| Natural Join     | `<table 1>.naturalJoin(<table 2>)`                                                             |
| Inner Join       | `<table 1>.join(<table 2>).on(<table 1 column constant>, <table 2 column constant>)`           |
| Left Outer Join  | `<table 1>.leftOuterJoin(<table 2>).on(<table 1 column constant>, <table 2 column constant>)`  |
| Right Outer Join | `<table 1>.rightOuterJoin(<table 2>).on(<table 1 column constant>, <table 2 column constant>)` |
| Full Outer Join  | `<table 1>.fullOuterJoin(<table 2>).on(<table 1 column constant>, <table 2 column constant>)`  |

An example that uses a left outer join would be:

```ts
QueryBuilder.select(User.USER_ID, UserData.NAME).from(User.leftOuterJoin(UserData).on(User.USER_ID, UserData.USER_ID));
```

##### Conditions

See [SQL Conditions](#sql-conditions).

In the case of `.select()` queries, the method `.where()` can be called on the result object of `.from()`.

##### Sorting

The result of a query can be sorted by using the method `.orderBy()`. This method expects the column constant of the column that should be sorted by and the order (which is either `'ascending'` or `'descending'`). The latter parameter can be left out. In this case, the order will default to `'ascending'`.

For example, the following query would query the names of all users and sort them in an descending manor:

```ts
QueryBuilder.select(User.NAME)
    .from(User)
    .orderBy(User.NAME, 'descending');
```

Calls to `.orderBy()` can be chained in order to sort by multiple columns.

##### Limiting The Output

The amount of queried rows can be limited with the method `.limit()`. It expects a single numeric parameter, which is the maximum amount of queried rows.

##### Full `.select()` Example

The following code is an example that queries the names five youngest users that are over the age of 21:

```ts
QueryBuilder.select(User.NAME)
    .from(User)
    .where(User.AGE.gt(21))
    .orderBy(User.AGE, 'ascending')
    .limit(5);
```

#### Insert Queries

The method `.insertInto()` is used to insert data into a table. It takes a single parameter, which is the table class that the data should be inserted into.

In order to insert a row, chain the method `.row()` after `.insertInto()`. `.row()` takes an object that contains the column values of the row. Each property in that object supplies a value for a column in the row. The key of the property is the name of the column and the value the actual column value. All columns that do not have default values defined are required in the object. However, columns with default values are not.

For example, the following could be used to create an insert query to insert a row into a table with the table class `User` and the columns `name` and `age`:

```ts
QueryBuilder.insertInto().row({
    name: 'my-test-user',
    age: 42
});
```

Note that `.row()` calls can be changed in order to insert multiple rows.

#### Update Queries

Update queries are created with the method `.update()`. It takes the table class of the table that is supposed to be updated as a parameter. The method `.set()` can be chained after `.update()` to set the columns that will be updated. Lastly, it is also possible to restrict the rows that should be updated with [Conditions](#sql-conditions).

##### Setting New Column Values

As already mentioned, column values can be updated with the method `.set()`. This method takes the column constant of the column that should be updated as its first parameter and the new value as its second. The type of the second parameter is determined of the column type:

<table style="text-align: center">
    <tr>
        <th>
            SQL Type
        </th>
        <th>
            <code>string</code>
        </th>
        <th>
            <code>number</code>
        </th>
        <th>
            <code>Date</code>
        </th>
        <th>
            <code>boolean</code>
        </th>
        <th>
            <code>enum literal</code>
        </th>
        <th>
            <code>null</code>
        </th>
    </tr>
    <tr>
        <th>
            <code>var-char</code>
        </th>
        <td>
            yes
        </td>
        <td>
            <!---->
        </td>
        <td>
            <!---->
        </td>
        <td>
            <!---->
        </td>
        <td>
            <!---->
        </td>
        <td>
            yes
        </td>
    </tr>
    <tr>
        <th>
            <code>char</code>
        </th>
        <td>
            yes
        </td>
        <td>
            <!---->
        </td>
        <td>
            <!---->
        </td>
        <td>
            <!---->
        </td>
        <td>
            <!---->
        </td>
        <td>
            yes
        </td>
    </tr>
    <tr>
        <th>
            <code>enum</code>
        </th>
        <td>
            <!---->
        </td>
        <td>
            <!---->
        </td>
        <td>
            <!---->
        </td>
        <td>
            <!---->
        </td>
        <td>
            yes
        </td>
        <td>
            yes
        </td>
    </tr>
    <tr>
        <th>
            <code>small-int</code>
        </th>
        <td>
            <!---->
        </td>
        <td>
            yes
        </td>
        <td>
            <!---->
        </td>
        <td>
            <!---->
        </td>
        <td>
            <!---->
        </td>
        <td>
            yes
        </td>
    </tr>
    <tr>
        <th>
            <code>int</code>
        </th>
        <td>
            <!---->
        </td>
        <td>
            yes
        </td>
        <td>
            <!---->
        </td>
        <td>
            <!---->
        </td>
        <td>
            <!---->
        </td>
        <td>
            yes
        </td>
    </tr>
    <tr>
        <th>
            <code>big-int</code>
        </th>
        <td>
            <!---->
        </td>
        <td>
            yes
        </td>
        <td>
            <!---->
        </td>
        <td>
            <!---->
        </td>
        <td>
            <!---->
        </td>
        <td>
            yes
        </td>
    </tr>
    <tr>
        <th>
            <code>float</code>
        </th>
        <td>
            <!---->
        </td>
        <td>
            yes
        </td>
        <td>
            <!---->
        </td>
        <td>
            <!---->
        </td>
        <td>
            <!---->
        </td>
        <td>
            yes
        </td>
    </tr>
    <tr>
        <th>
            <code>double</code>
        </th>
        <td>
            <!---->
        </td>
        <td>
            yes
        </td>
        <td>
            <!---->
        </td>
        <td>
            <!---->
        </td>
        <td>
            <!---->
        </td>
        <td>
            yes
        </td>
    </tr>
    <tr>
        <th>
            <code>time</code>
        </th>
        <td>
            <!---->
        </td>
        <td>
            <!---->
        </td>
        <td>
            yes
        </td>
        <td>
            <!---->
        </td>
        <td>
            <!---->
        </td>
        <td>
            yes
        </td>
    </tr>
    <tr>
        <th>
            <code>date</code>
        </th>
        <td>
            <!---->
        </td>
        <td>
            <!---->
        </td>
        <td>
            yes
        </td>
        <td>
            <!---->
        </td>
        <td>
            <!---->
        </td>
        <td>
            yes
        </td>
    </tr>
    <tr>
        <th>
            <code>date-time</code>
        </th>
        <td>
            <!---->
        </td>
        <td>
            <!---->
        </td>
        <td>
            yes
        </td>
        <td>
            <!---->
        </td>
        <td>
            <!---->
        </td>
        <td>
            yes
        </td>
    </tr>
    <tr>
        <th>
            <code>boolean</code>
        </th>
        <td>
            <!---->
        </td>
        <td>
            <!---->
        </td>
        <td>
            <!---->
        </td>
        <td>
            yes
        </td>
        <td>
            <!---->
        </td>
        <td>
            yes
        </td>
    </tr>
</table>

#### Delete Queries

Delete queries can be created with the method `.deleteFrom()`. It takes the table class of the table that rows should be deleted from. A [Condition](#sql-conditions) can be chained to it.

#### SQL Conditions

Conditions can be used to restrict SQL queries. For example, the can be used with a `.select()` query to only query certain rows that meet a certain condition. Conditions are created using the `.where()` method and they are the equivalent of the `WHERE` SQL clause.

`.where()` only takes a single condition. However, it is possible to combine multiple conditions into a single by using the functions `.and()` and `.or()` in the query builder module.

These two functions work like this:

```ts
// .and()
// this creates a condition that would be equivalent to the SQL condition
// <condition 1> AND <condition 2> AND <condition 3>
and(
    <condition 1>,
    <condition 2>,
    <condition 3>
)

// .or()
// this creates a condition that would be equivalent to the SQL condition
// <condition 1> OR <condition 2> OR <condition 3>
or(
    <condition 1>,
    <condition 2>,
    <condition 3>
)
```

Naturally, it is also possible to nest `.and()` and `.or()` in each other:

```ts
// this creates a condition that would be equivalent to the SQL condition
// <condition 1> AND (<condition 2> OR <condition 3>)
and(
    <condition 1>,
    or(
        <condition 2>,
        <condition 3>
    )
)
```

There is also a third logical operation that can be done with the function `.not()`. This function only takes a single condition and inverts its result.

##### Creating Conditions

Conditions can be created using the column constants. Each of the constants contain methods to create conditions that match their type. These are:

<table>
    <tr>
        <th>
            Type
        </th>
        <th>
            Method
        </th>
        <th>
            Parameters
        </th>
        <th>
            Note
        </th>
    </tr>
    <tr>
        <td rowspan="11">
            <code>var-char</code><br/>
            <code>char</code>
        </td>
        <td rowspan="3">
            <code>.equals()</code>
        </td>
        <td>
            Column Constant
        </td>
        <td>
            Checks if the values of the two rows are the same.
        </td>
    </tr>
    <tr>
        <td>
            String Literal / String Variable
        </td>
        <td>
            Checks if the row and string values are the same.
        </td>
    </tr>
    <tr>
        <td>
            <code>null</code> / variable that is <code>null</code>
        </td>
        <td>
            Checks if the row value is <code>null</code>.
        </td>
    </tr>
    <tr>
        <td rowspan="3">
            <code>.notEquals()</code>
        </td>
        <td>
            Column Constant
        </td>
        <td>
            Checks if the values of the two rows are different.
        </td>
    </tr>
    <tr>
        <td>
            String Literal / String Variable
        </td>
        <td>
            Checks if the row and string values are different.
        </td>
    </tr>
    <tr>
        <td>
            <code>null</code> / variable that is <code>null</code>
        </td>
        <td>
            Checks if the row value is not <code>null</code>.
        </td>
    </tr>
    <tr>
        <td rowspan="2">
            <code>.contains()</code>
        </td>
        <td>
            Column Constant
        </td>
        <td>
            Checks if the value of the left row contains the right row value.
        </td>
    </tr>
    <tr>
        <td>
            String Literal / String Variable
        </td>
        <td>
            Checks if the row value contains the value of the string value.
        </td>
    </tr>
    <tr>
        <td rowspan="2">
            <code>.isContainedIn()</code>
        </td>
        <td>
            Column Constant
        </td>
        <td>
            Checks if the right row value contains the left row value.
        </td>
    </tr>
    <tr>
        <td>
            String Literal / String Variable
        </td>
        <td>
            Checks if the string value contains the row value.
        </td>
    </tr>
    <tr>
        <td>
            <code>.matches()</code>
        </td>
        <td>
            Regex
        </td>
        <td>
            Checks if the row value matches the passed regular expression.
        </td>
    </tr>
    <tr>
        <td rowspan="6">
            <code>enum</code>
        </td>
        <td rowspan="3">
            <code>.equals()</code>
        </td>
        <td>
            Column Constant
        </td>
        <td>
            Checks if the values of the two rows are the same.
        </td>
    </tr>
    <tr>
        <td>
            String Literal / String Variable
        </td>
        <td>
            Checks if the row and string values are the same.
        </td>
    </tr>
    <tr>
        <td>
            <code>null</code> / variable that is <code>null</code>
        </td>
        <td>
            Checks if the row value is <code>null</code>.
        </td>
    </tr>
    <tr>
        <td rowspan="3">
            <code>.notEquals()</code>
        </td>
        <td>
            Column Constant
        </td>
        <td>
            Checks if the values of the two rows are different.
        </td>
    </tr>
    <tr>
        <td>
            String Literal / String Variable
        </td>
        <td>
            Checks if the row and string values are different.
        </td>
    </tr>
    <tr>
        <td>
            <code>null</code> / variable that is <code>null</code>
        </td>
        <td>
            Checks if the row value is not <code>null</code>.
        </td>
    </tr>
    <tr>
        <td rowspan="14">
            <code>small-int</code><br/>
            <code>int</code><br/>
            <code>big-int</code><br/>
            <code>float</code><br/>
            <code>double</code>
        </td>
        <td rowspan="3">
            <code>.equals()</code>
        </td>
        <td>
            Column Constant
        </td>
        <td>
            Checks if the values of the two rows are the same.
        </td>
    </tr>
    <tr>
        <td>
            Number Variable / Number Constant
        </td>
        <td>
            Checks if the row value is the same as the passed value.
        </td>
    </tr>
    <tr>
        <td>
            <code>null</code> / variable that is <code>null</code>
        </td>
        <td>
            Checks if the row value is <code>null</code>.
        </td>
    </tr>
    <tr>
        <td rowspan="3">
            <code>.notEquals()</code>
        </td>
        <td>
            Column Constant
        </td>
        <td>
            Checks if the two row values are different.
        </td>
    </tr>
    <tr>
        <td>
            Number Variable / Number Constant
        </td>
        <td>
            Checks whether the row value is different from the passed value.
        </td>
    </tr>
    <tr>
        <td>
            <code>null</code> / variable that is <code>null</code>
        </td>
        <td>
            Checks whether the row is not <code>null</code>.
        </td>
    </tr>
    <tr>
        <td rowspan="2">
            <code>.gt()</code>
        </td>
        <td>
            Column Constant
        </td>
        <td>
            Checks if the value of the left row is greater than the value of the right row.
        </td>
    </tr>
    <tr>
        <td>
            Number Variable / Number Constant
        </td>
        <td>
            Checks if the value of the left row is greater than the passed value.
        </td>
    </tr>
    <tr>
        <td rowspan="2">
            <code>.gtEq()</code>
        </td>
        <td>
            Column Constant
        </td>
        <td>
            Checks if the value of the left row is greater than or equal to the value of the right row.
        </td>
    </tr>
    <tr>
        <td>
            Number Variable / Number Constant
        </td>
        <td>
            Checks if the value of the left row is greater than or equal to the passed value.
        </td>
    </tr>
    <tr>
        <td rowspan="2">
            <code>.lt()</code>
        </td>
        <td>
            Column Constant
        </td>
        <td>
            Checks if the value of the left row is lower than the value of the right row.
        </td>
    </tr>
    <tr>
        <td>
            Number Variable / Number Constant
        </td>
        <td>
            Checks if the value of the left row is lower than the passed value.
        </td>
    </tr>
    <tr>
        <td rowspan="2">
            <code>.ltEq()</code>
        </td>
        <td>
            Column Constant
        </td>
        <td>
            Checks if the value of the left row is lower than or equal to the value of the right row.
        </td>
    </tr>
    <tr>
        <td>
            Number Variable / Number Constant
        </td>
        <td>
            Checks if the value of the left row is lower than or equal the passed value.
        </td>
    </tr>
    <tr>
        <td rowspan="14">
            <code>date</code><br/>
            <code>time</code><br/>
            <code>date-time</code>
        </td>
        <td rowspan="3">
            <code>.equals()</code>
        </td>
        <td>
            Column Constant
        </td>
        <td>
            Checks if the values of the two rows are the same.
        </td>
    </tr>
    <tr>
        <td>
            Number Variable / Number Constant
        </td>
        <td>
            Checks if the row value is the same as the passed value.
        </td>
    </tr>
    <tr>
        <td>
            <code>null</code> / variable that is <code>null</code>
        </td>
        <td>
            Checks if the row value is <code>null</code>.
        </td>
    </tr>
    <tr>
        <td rowspan="3">
            <code>.notEquals()</code>
        </td>
        <td>
            Column Constant
        </td>
        <td>
            Checks if the two row values are different.
        </td>
    </tr>
    <tr>
        <td>
            Number Variable / Number Constant
        </td>
        <td>
            Checks whether the row value is different from the passed value.
        </td>
    </tr>
    <tr>
        <td>
            <code>null</code> / variable that is <code>null</code>
        </td>
        <td>
            Checks whether the row is not <code>null</code>.
        </td>
    </tr>
    <tr>
        <td rowspan="2">
            <code>.gt()</code>
        </td>
        <td>
            Column Constant
        </td>
        <td>
            Checks if the value of the left row is greater than the value of the right row.
        </td>
    </tr>
    <tr>
        <td>
            Number Variable / Number Constant
        </td>
        <td>
            Checks if the value of the left row is greater than the passed value.
        </td>
    </tr>
    <tr>
        <td rowspan="2">
            <code>.gtEq()</code>
        </td>
        <td>
            Column Constant
        </td>
        <td>
            Checks if the value of the left row is greater than or equal to the value of the right row.
        </td>
    </tr>
    <tr>
        <td>
            Number Variable / Number Constant
        </td>
        <td>
            Checks if the value of the left row is greater than or equal to the passed value.
        </td>
    </tr>
    <tr>
        <td rowspan="2">
            <code>.lt()</code>
        </td>
        <td>
            Column Constant
        </td>
        <td>
            Checks if the value of the left row is lower than the value of the right row.
        </td>
    </tr>
    <tr>
        <td>
            Number Variable / Number Constant
        </td>
        <td>
            Checks if the value of the left row is lower than the passed value.
        </td>
    </tr>
    <tr>
        <td rowspan="2">
            <code>.ltEq()</code>
        </td>
        <td>
            Column Constant
        </td>
        <td>
            Checks if the value of the left row is lower than or equal to the value of the right row.
        </td>
    </tr>
    <tr>
        <td>
            Number Variable / Number Constant
        </td>
        <td>
            Checks if the value of the left row is lower than or equal the passed value.
        </td>
    </tr>
    <tr>
        <td rowspan="6">
            <code>boolean</code>
        </td>
        <td rowspan="3">
            <code>.equals()</code>
        </td>
        <td>
            Column Constant
        </td>
        <td>
            Checks if the values of the two rows are the same.
        </td>
    </tr>
    <tr>
        <td>
            <code>true</code> / <code>false</code> / boolean variable
        </td>
        <td>
            Checks if the row and string values are the same.
        </td>
    </tr>
    <tr>
        <td>
            <code>null</code> / variable that is <code>null</code>
        </td>
        <td>
            Checks if the row value is <code>null</code>.
        </td>
    </tr>
    <tr>
        <td rowspan="3">
            <code>.notEquals()</code>
        </td>
        <td>
            Column Constant
        </td>
        <td>
            Checks if the values of the two rows are different.
        </td>
    </tr>
    <tr>
        <td>
            <code>true</code> / <code>false</code> / boolean variable
        </td>
        <td>
            Checks if the row and string values are different.
        </td>
    </tr>
    <tr>
        <td>
            <code>null</code> / variable that is null
        </td>
        <td>
            Checks if the row value is not <code>null</code>.
        </td>
    </tr>
</table>

For example, the following code would create a condition that checks whether the column `NAME` is `my-test-user` and `AGE` is greater than or equal to `18` (both columns are in the table `User`):

```ts
and(User.NAME.equals('my-test-user'), User.AGE.gtEq(18));
```

#### Executing Queries

As soon as a query is ready to execute (which it is after the correct methods have been chained, for example, `.select()` and `.from()` for a select query), it is possible to call the method `.execute()` on it.

This will return an object that contains the result of the query. The object's layout depends on the type of query that was executed.

##### Select Query Layout

The result object of a select query contains a single property `rows`: It is an array and each element in it contains the selected columns of a row. Naturally, the layout of the row objects varies depending on the selected columns. However, the keys in that object are always the names of the columns (or the name that was given to the column with `.as()`) and the values are the respective values of the columns. Depending on the SQL datatype, the column values will have the following types (keep in mind that the type may also be `null`, depending on the nullableness of the column).

| SQL Type    | JS / TS Type |
| ----------- | ------------ |
| `var-char`  | `string`     |
| `char`      | `string`     |
| `small-int` | `number`     |
| `int`       | `number`     |
| `big-int`   | `number`     |
| `float`     | `number`     |
| `double`    | `number`     |
| `date`      | `Date`       |
| `time`      | `Date`       |
| `date-time` | `Date`       |
| `boolean`   | `boolean`    |

###### Example

The result object of the query

```ts
QueryBuilder.select(User.NAME, User.AGE)
    .from(User)
    .execute();
```

on a table with the following data

| name           | age |
| -------------- | --- |
| my-first-user  | 13  |
| my-second-user | 37  |

would look like this:

```ts
{
    rows: [
        {
            name: 'my-first-user',
            age: 13
        },
        {
            name: 'my-second-user',
            age: 37
        }
    ];
}
```

##### Insert Query Layout

The result object of an insert query contains a property `insertId`. This is the value of the primary key that was last inserted. There is also an additional property `insertIds`. This is an array that contains the primary key values of all inserted rows. This can be used when multiple rows have been inserted (i.e. `.set()` was called multiple times). The primary keys are stored in the same order as the rows have been created (the row created through the first `.set()` has the index 0, the row created through the second `.set()` has the index 1, and so on).

For example, the following insert query

```ts
QueryBuilder.insertInto(User)
    .set({ id: 0, name: 'my-first-user', age: 13 })
    .set({ id: 1, name: 'my-second-user', age: 37 })
    .execute();
```

would result in the following object (the column `id` is the primary key):

```ts
{
    insertId: 1,
    insertIds: [
        0,
        1
    ]
}
```

##### Update And Delete Query Layout

Update and delete queries share the same result object layout. It contains a single property `affectedRows` which, depending on the query type, signalizes the amount of updated or deleted rows.

For example, the update query

```ts
QueryBuilder.update(User)
    .set(User.AGE, 42)
    .execute();
```

on a table with two users would result in the following result object:

```ts
{
    affectedRows: 2;
}
```

### Transactions

Transactions can be started from the connection instance. This can be acquired through the public static property `connection` that is available in each of the table classes and the query builder. It can also be imported<!--todo from where?-->.

In order to start a transaction, use the method `.transaction()`. It expects a callback that contains the code for the transaction. The callback has a special object, that represents the connection that the transaction is on, as a parameter. This object can be passed to all methods that interact with the database. These are:

1. table class getters
2. table class setters
3. other table class methods that interact with the database (such as `.exists()`)
4. QueryBuilder's `.execute()`

In the case of methods that expect

#### Example

The following bit of code would first check for a users existence and then query its name within a single transaction (assume that the objects `connection` and `user` are already defined):

```ts
connection.transaction(async conn => {
    if (await user.exists(conn)) {
        const name = await user.getName(conn);
    }
});
```

#### Return Value

It is also possible to return a value from the transaction callback. This value will then be returned by `.transaction()`. The ability to return values does not directly have anything to do with transactions itself, however, it makes for cleaner code if the transaction produces a result.

The example from above would look like this, if the name of the user is returned:

```ts
const name = await connection.transaction(async conn => {
    if (await user.exists(conn)) {
        return user.getName(conn);
    } else {
        return null;
    }
});
```

#### Committing and Rollback

The `.transaction()` method will automatically begin a transaction before calling the callback and it will automatically commit after it ends. However, if an error is thrown during the transaction, it automatically be rolled back. After the rollback, the error will be re-thrown by `.transaction()`.

#### Freeform Transactions

Instead of using the `.transaction()` method, it is also possible to begin, commit and rollback manually. Such a transaction is created by calling `.beginTransaction()` in the connection object. This object can then be passed to database methods, just like the callback parameter of the `.transaction()` callback. The transaction can be committed or rolled by back calling `.commit()` or `.rollback()` on the transaction object. For example:

```ts
const transaction = await connection.beginTransaction();

if (await user.exists(transaction)) {
    const name = await user.getName();
}

await transaction.commit();
```

### Multiple Connections

Usually, each method that interacts with a database uses a new connection from a connection pool. However, it is also possible to re-use a single connection from that pool. This is done with the method `.multiQuery()` in the connection. It is very similar to `.transaction()`, as in `.multiQuery()` too expects a callback that has the connection as a parameter which can be passed to database methods. The key difference, of course, is the lack of a transaction in the case of `.multiQuery()`. The following code is the same example as in [Transaction Return Value](#return-value), but with a multi query instead of a transaction:

```ts
const name = await connection.multiQuery(async conn => {
    if (await user.exists(conn)) {
        return user.getName(conn);
    } else {
        return null;
    }
});
```

### Low Level Database Access

The connection object also allows the execution of SQL from regular SQL strings. This can be done through the method `.query()`, which expects the SQL string and, optionally, binding parameters.

For example, the following query would query all users with the name that is stored in the variable `name`:

```ts
connection.query('SELECT * FROM Users WHERE name = ?', [name]);
```

The method `.query()` also exists in the parameter object of the `.transaction()` and `.multiQuery()` methods.

<!--

Todo:

- constraints
- triggers

- naming functions (JS function that can be called to return a name instead of hard-coding it)
- query builder .groupBy()
- query builder sub-queries

- Creating drivers
-->

<!--
processing phases:

- validation
- include resolve
- partial table resolve (move partial tables to database level)
- partial table validation (circular include + existence)
- column def resolve
- type def resolve
- foreign key resolve
    - make sure tables and columns exist
    - make sure types match TODO
- type checks
    - default null
    - enum default literal
- name resolve
    - modify plural table names to singular ones
    - case-adjust all names

-->
